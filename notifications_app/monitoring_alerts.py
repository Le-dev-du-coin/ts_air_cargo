"""
Syst√®me de monitoring avec alertes automatiques pour TS Air Cargo
Surveille les m√©triques critiques et envoie des alertes admin automatiquement

M√©triques surveill√©es:
- √âchecs OTP r√©p√©t√©s
- Pannes instances WhatsApp  
- Erreurs de base de donn√©es
- Exceptions syst√®me non g√©r√©es
- Performance d√©grad√©e
"""

import logging
import threading
import time
from collections import defaultdict, deque
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional
from django.utils import timezone
from django.core.cache import cache
from django.db import connections
from .admin_alerts import admin_alerts

logger = logging.getLogger(__name__)


class SystemMonitor:
    """
    Moniteur syst√®me principal avec alertes automatiques
    """
    
    def __init__(self):
        """Initialise le moniteur"""
        self.is_monitoring = False
        self.monitor_thread = None
        
        # Compteurs pour les m√©triques
        self.otp_failures = deque(maxlen=100)  # Derniers 100 √©checs OTP
        self.whatsapp_failures = defaultdict(int)  # √âchecs par instance
        self.db_errors = deque(maxlen=50)  # Derni√®res 50 erreurs DB
        self.system_exceptions = deque(maxlen=50)  # Derni√®res 50 exceptions
        
        # M√©triques de performance
        self.response_times = defaultdict(lambda: deque(maxlen=100))
        self.last_health_check = timezone.now()
        
        # √âtats des alertes pour √©viter le spam
        self.alert_states = {
            'otp_failures': False,
            'whatsapp_china_down': False,
            'whatsapp_mali_down': False,
            'whatsapp_system_down': False,
            'db_errors': False,
            'high_exception_rate': False
        }
    
    def start_monitoring(self):
        """D√©marre le monitoring en arri√®re-plan"""
        if self.is_monitoring:
            logger.warning("Monitoring d√©j√† en cours")
            return
        
        self.is_monitoring = True
        self.monitor_thread = threading.Thread(target=self._monitor_loop, daemon=True)
        self.monitor_thread.start()
        logger.info("üîç Monitoring syst√®me d√©marr√©")
        
        # Alerte de d√©marrage
        admin_alerts.send_critical_alert(
            title="Monitoring Syst√®me D√©marr√©",
            message="Le syst√®me de monitoring et d'alertes automatiques a √©t√© d√©marr√© avec succ√®s.",
            alert_type="INFO"
        )
    
    def stop_monitoring(self):
        """Arr√™te le monitoring"""
        if not self.is_monitoring:
            return
        
        self.is_monitoring = False
        logger.info("üîç Monitoring syst√®me arr√™t√©")
    
    def _monitor_loop(self):
        """Boucle principale de monitoring"""
        while self.is_monitoring:
            try:
                self._check_otp_failures()
                self._check_whatsapp_health()
                self._check_database_health()
                self._check_exception_rate()
                self._update_health_status()
                
                # Pause entre v√©rifications
                time.sleep(60)  # V√©rification toutes les minutes
                
            except Exception as e:
                logger.error(f"Erreur dans la boucle de monitoring: {str(e)}")
                self.record_system_exception(e, "Monitoring Loop")
                time.sleep(30)  # Pause plus courte en cas d'erreur
    
    def record_otp_failure(self, phone: str, reason: str = "Unknown"):
        """Enregistre un √©chec d'OTP"""
        failure_data = {
            'timestamp': timezone.now(),
            'phone': phone,
            'reason': reason
        }
        self.otp_failures.append(failure_data)
        logger.debug(f"OTP √©chec enregistr√©: {phone} - {reason}")
    
    def record_whatsapp_failure(self, instance: str, error_message: str = ""):
        """Enregistre un √©chec WhatsApp"""
        self.whatsapp_failures[instance] += 1
        failure_key = f"whatsapp_failure_{instance}_{timezone.now().date()}"
        cache.set(failure_key, self.whatsapp_failures[instance], timeout=86400)  # 24h
        logger.debug(f"√âchec WhatsApp enregistr√©: {instance} - {error_message}")
    
    def record_whatsapp_success(self, instance: str):
        """Enregistre un succ√®s WhatsApp (reset compteur)"""
        if self.whatsapp_failures[instance] > 0:
            self.whatsapp_failures[instance] = max(0, self.whatsapp_failures[instance] - 1)
        
        # Reset √©tat d'alerte si retour √† la normale
        alert_key = f'whatsapp_{instance}_down'
        if alert_key in self.alert_states and self.alert_states[alert_key]:
            self.alert_states[alert_key] = False
            admin_alerts.send_critical_alert(
                title=f"Instance WhatsApp {instance.title()} R√©cup√©r√©e",
                message=f"L'instance WhatsApp {instance} fonctionne √† nouveau normalement.",
                alert_type="INFO"
            )
    
    def record_db_error(self, error_message: str, query_info: str = None):
        """Enregistre une erreur de base de donn√©es"""
        error_data = {
            'timestamp': timezone.now(),
            'message': error_message,
            'query': query_info
        }
        self.db_errors.append(error_data)
        logger.warning(f"Erreur DB enregistr√©e: {error_message}")
    
    def record_system_exception(self, exception: Exception, context: str = None):
        """Enregistre une exception syst√®me"""
        exception_data = {
            'timestamp': timezone.now(),
            'exception': str(exception),
            'type': type(exception).__name__,
            'context': context
        }
        self.system_exceptions.append(exception_data)
        logger.error(f"Exception syst√®me enregistr√©e: {str(exception)}")
    
    def record_response_time(self, operation: str, response_time_ms: float):
        """Enregistre un temps de r√©ponse"""
        self.response_times[operation].append({
            'timestamp': timezone.now(),
            'response_time': response_time_ms
        })
    
    def _check_otp_failures(self):
        """V√©rifie les √©checs OTP r√©p√©t√©s"""
        if not self.otp_failures:
            return
        
        # Compter les √©checs dans la derni√®re heure
        one_hour_ago = timezone.now() - timedelta(hours=1)
        recent_failures = [f for f in self.otp_failures if f['timestamp'] > one_hour_ago]
        
        if len(recent_failures) >= admin_alerts.failed_otp_threshold:
            if not self.alert_states['otp_failures']:
                self.alert_states['otp_failures'] = True
                admin_alerts.alert_failed_otp_threshold(len(recent_failures), "1 heure")
        else:
            self.alert_states['otp_failures'] = False
    
    def _check_whatsapp_health(self):
        """V√©rifie l'√©tat des instances WhatsApp"""
        instances = ['chine', 'mali', 'system']
        
        for instance in instances:
            consecutive_failures = self.whatsapp_failures.get(instance, 0)
            alert_key = f'whatsapp_{instance}_down'
            
            if consecutive_failures >= admin_alerts.whatsapp_failure_threshold:
                if not self.alert_states[alert_key]:
                    self.alert_states[alert_key] = True
                    admin_alerts.alert_whatsapp_instance_down(instance.title(), consecutive_failures)
            elif consecutive_failures == 0:
                self.alert_states[alert_key] = False
    
    def _check_database_health(self):
        """V√©rifie l'√©tat de la base de donn√©es"""
        try:
            # Test simple de connexion
            from django.db import connection
            with connection.cursor() as cursor:
                cursor.execute("SELECT 1")
                
            # Si nous arrivons ici, la DB fonctionne
            if self.alert_states.get('db_connection_lost', False):
                self.alert_states['db_connection_lost'] = False
                admin_alerts.send_critical_alert(
                    title="Connexion Base de Donn√©es R√©cup√©r√©e",
                    message="La connexion √† la base de donn√©es fonctionne √† nouveau normalement.",
                    alert_type="INFO"
                )
                
        except Exception as e:
            if not self.alert_states.get('db_connection_lost', False):
                self.alert_states['db_connection_lost'] = True
                admin_alerts.alert_database_error(str(e), "Test de connexion monitoring")
    
    def _check_exception_rate(self):
        """V√©rifie le taux d'exceptions syst√®me"""
        if not self.system_exceptions:
            return
        
        # Compter les exceptions dans les 10 derni√®res minutes
        ten_minutes_ago = timezone.now() - timedelta(minutes=10)
        recent_exceptions = [e for e in self.system_exceptions if e['timestamp'] > ten_minutes_ago]
        
        # Si plus de 5 exceptions en 10 minutes, c'est critique
        if len(recent_exceptions) >= 5:
            if not self.alert_states['high_exception_rate']:
                self.alert_states['high_exception_rate'] = True
                admin_alerts.send_critical_alert(
                    title="Taux d'Exceptions Syst√®me √âlev√©",
                    message=f"{len(recent_exceptions)} exceptions syst√®me en 10 minutes. Investigation requise.",
                    error_details=f"Derni√®res exceptions: {[e['exception'] for e in recent_exceptions[-3:]]}",
                    alert_type="CRITICAL"
                )
        else:
            self.alert_states['high_exception_rate'] = False
    
    def _update_health_status(self):
        """Met √† jour le statut g√©n√©ral de sant√© du syst√®me"""
        self.last_health_check = timezone.now()
        
        # Statistiques g√©n√©rales
        cache.set('system_health_last_check', self.last_health_check, timeout=300)
        cache.set('system_health_otp_failures_hour', len([
            f for f in self.otp_failures 
            if f['timestamp'] > timezone.now() - timedelta(hours=1)
        ]), timeout=300)
        cache.set('system_health_active_alerts', sum(1 for state in self.alert_states.values() if state), timeout=300)
    
    def get_system_status(self) -> Dict[str, Any]:
        """Retourne le statut complet du syst√®me"""
        one_hour_ago = timezone.now() - timedelta(hours=1)
        ten_minutes_ago = timezone.now() - timedelta(minutes=10)
        
        return {
            'monitoring_active': self.is_monitoring,
            'last_health_check': self.last_health_check,
            'alerts_active': sum(1 for state in self.alert_states.values() if state),
            'metrics': {
                'otp_failures_last_hour': len([f for f in self.otp_failures if f['timestamp'] > one_hour_ago]),
                'whatsapp_failures': dict(self.whatsapp_failures),
                'db_errors_last_hour': len([e for e in self.db_errors if e['timestamp'] > one_hour_ago]),
                'exceptions_last_10min': len([e for e in self.system_exceptions if e['timestamp'] > ten_minutes_ago])
            },
            'alert_states': self.alert_states
        }
    
    def get_health_summary(self) -> str:
        """Retourne un r√©sum√© textuel de l'√©tat du syst√®me"""
        status = self.get_system_status()
        
        if status['alerts_active'] == 0:
            return "üü¢ Syst√®me en bonne sant√©"
        elif status['alerts_active'] <= 2:
            return "üü° Syst√®me avec alertes mineures"
        else:
            return "üî¥ Syst√®me avec probl√®mes critiques"


# Instance globale du moniteur
system_monitor = SystemMonitor()


# D√©corateur pour monitorer automatiquement les fonctions
def monitor_performance(operation_name: str):
    """
    D√©corateur pour monitorer la performance d'une op√©ration
    
    Usage:
    @monitor_performance("envoi_otp")
    def send_otp(phone, code):
        # code de la fonction
        pass
    """
    def decorator(func):
        def wrapper(*args, **kwargs):
            start_time = time.time()
            try:
                result = func(*args, **kwargs)
                response_time = (time.time() - start_time) * 1000  # en ms
                system_monitor.record_response_time(operation_name, response_time)
                return result
            except Exception as e:
                system_monitor.record_system_exception(e, f"Fonction: {func.__name__}")
                raise
        return wrapper
    return decorator


# Fonctions utilitaires
def start_system_monitoring():
    """D√©marre le monitoring syst√®me"""
    system_monitor.start_monitoring()


def stop_system_monitoring():
    """Arr√™te le monitoring syst√®me"""
    system_monitor.stop_monitoring()


def get_system_health() -> Dict[str, Any]:
    """Retourne l'√©tat de sant√© du syst√®me"""
    return system_monitor.get_system_status()


def send_test_alert():
    """Envoie une alerte de test"""
    return admin_alerts.test_alert_system()
